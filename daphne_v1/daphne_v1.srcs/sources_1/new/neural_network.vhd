----------------------------------------------------------------------------------
-- Company: Universidad EIA
-- Engineer: Daniel Avila Gomez
-- 
-- Create Date: 06.10.2023 14:44:00
-- Design Name: Neural Network Second Build
-- Module Name: neural_network_2 - Behavioral
-- Project Name: Neural Network Self Trigger for DAPHNE
-- Target Devices: XC7A200T-1SBG484C
-- Tool Versions: 2023.1 
-- Description: 
-- Creates the structure of a 16 input, 12 hidden, 1 output neural network
-- Dependencies: 
-- 
-- Revision:
-- Revision 0.01 - File Created
-- Additional Comments:
-- 
----------------------------------------------------------------------------------


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
use IEEE.NUMERIC_STD.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity neural_network is
    Generic (
        -- DSP Slices For Internal Multiplication Parameters
    -------------------------------------------------------------------------------------------------------------------------------------------
        A_IN_SIZE       : integer   := 30;                                      -- Input Size Of The A Vector For The DSP Slice
        B_IN_SIZE       : integer   := 18;                                      -- Input Size Of The B Vector For The DSP Slice
        
        -- Representation Of The Weights And BIASES Parameters
    -------------------------------------------------------------------------------------------------------------------------------------------
        W_BIT_WIDTH     : integer   := 25;                                      -- Weights Representation Total Size 
        W_B_RES         : integer   := 14;                                      -- Fractional Resolution Of The Weights
        B1_SIZE_INT     : integer   := 12;                                      -- Integer Size Of The Input BIAS
        B1_SIZE_FRAC    : integer   := 27;                                      -- Fractional Size Of The Input BIAS                       
        B2_SIZE_INT     : integer   := 19;                                      -- Integer Size Of The Hidden BIAS    
        B2_SIZE_FRAC    : integer   := 25;                                      -- Fractional Size Of The Hidden BIAS
        
        -- Neural Network Structure Parameters
    ------------------------------------------------------------------------------------------------------------------------------------------- 
        W_SIZE          : integer   := 16;                                      -- Size Of The Window Of Registers Used By The Neural Network
        N_HIDDEN        : integer   := 12;                                      -- Number Of Hidden Neurons in the Hidden Layer
        -- Originally 64 registers were used for the pre window, with pipelining, the delay increased 13 clk cycles
        -- Therefore the number increases to 77 registers. With two more delays generated by the filters, the value may increase to
        -- 78 with one filter used and 79 with two cascaded filters used
        PRE_W_SIZE      : integer   := 64;                                      -- Number Of Pre Samples to Store in The FIFO 
        
        -- Size Of The Input Data
    ------------------------------------------------------------------------------------------------------------------------------------------- 
        DATA_WIDTH      : integer   := 14                                       -- Width Of The Input Vector Of Data
    );
    Port ( 
        -- Module Inputs
    -------------------------------------------------------------------------------------------------------------------------------------------
        clk             : in std_logic;                                         -- Clock Used By The Module                                     
        rst             : in std_logic;                                         -- Async Reset
        data_valid      : in std_logic;                                         -- Data Alligned
        filt_data       : in std_logic_vector((DATA_WIDTH - 1) downto 0);       -- Data Under Test For Trigger Pattern (Filtered Data)
        data            : in std_logic_vector((DATA_WIDTH - 1) downto 0);       -- Real Data Sampled By The AFE
        
        -- Module Outputs
    -------------------------------------------------------------------------------------------------------------------------------------------        
        trigger_o       : out std_logic;                                        -- Trigger Output Enabled By the data_valid Input
        y_predict_o     : out signed((A_IN_SIZE + B_IN_SIZE - 1) downto 0);     -- Prediction By The Neural Network
        y_j_o           : out signed((A_IN_SIZE + B_IN_SIZE - 1) downto 0);     -- Aggregation Of The Output of The Neural Network
        trigger_aux     : out std_logic;                                        -- Trigger Output Made By The Neural Network
        norm_dt         : out signed(DATA_WIDTH downto 0);                      -- Normalized Version Of The Data Used By The Module
        o_data          : out std_logic_vector((DATA_WIDTH - 1) downto 0)       -- Output Real Data Of The Module (Delayed By 64/n Samples)
    );
end neural_network;

architecture nNPM_arch of neural_network is

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- Declare the activation function of the hidden layer (Rectified Linear Unit)
-- Signed version
function ReLU (
    x : in signed((A_IN_SIZE + B_IN_SIZE - 1) downto 0))
    return signed is
    variable y : signed((A_IN_SIZE + B_IN_SIZE - 1) downto 0);
    begin
        if (x > 0) then
            y := shift_right(x,16);
        else
            y := (others => '0');  
        end if;
    return y;
end;

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- Declare the activation function of the output layer (Sigmoid)
-- Signed 10 partitions version
function Sigmoid (
    x : in signed((A_IN_SIZE + B_IN_SIZE - 1) downto 0))
    return signed is
    variable y : signed((A_IN_SIZE + B_IN_SIZE - 1) downto 0);
    variable x_aux : signed((A_IN_SIZE + B_IN_SIZE - 1) downto 0);
    constant zero : signed((A_IN_SIZE + B_IN_SIZE - 1) downto 0) := to_signed(integer(0),(A_IN_SIZE + B_IN_SIZE));
    constant one : signed((A_IN_SIZE + B_IN_SIZE - 1) downto 0) := to_signed(integer(16777216),(A_IN_SIZE + B_IN_SIZE));
    constant p1 : signed((A_IN_SIZE + B_IN_SIZE - 1) downto 0) := to_signed(integer(-134217728),(A_IN_SIZE + B_IN_SIZE));
    constant p2 : signed((A_IN_SIZE + B_IN_SIZE - 1) downto 0) := to_signed(integer(-75497472),(A_IN_SIZE + B_IN_SIZE));
    constant p3 : signed((A_IN_SIZE + B_IN_SIZE - 1) downto 0) := to_signed(integer(-50331648),(A_IN_SIZE + B_IN_SIZE));
    constant p4 : signed((A_IN_SIZE + B_IN_SIZE - 1) downto 0) := to_signed(integer(-33554432),(A_IN_SIZE + B_IN_SIZE));
    constant p5 : signed((A_IN_SIZE + B_IN_SIZE - 1) downto 0) := to_signed(integer(-16777216),(A_IN_SIZE + B_IN_SIZE));
    constant p6 : signed((A_IN_SIZE + B_IN_SIZE - 1) downto 0) := to_signed(integer(16777216),(A_IN_SIZE + B_IN_SIZE));
    constant p7 : signed((A_IN_SIZE + B_IN_SIZE - 1) downto 0) := to_signed(integer(33554432),(A_IN_SIZE + B_IN_SIZE));
    constant p8 : signed((A_IN_SIZE + B_IN_SIZE - 1) downto 0) := to_signed(integer(50331648),(A_IN_SIZE + B_IN_SIZE));
    constant p9 : signed((A_IN_SIZE + B_IN_SIZE - 1) downto 0) := to_signed(integer(75497472),(A_IN_SIZE + B_IN_SIZE));
    constant p10 : signed((A_IN_SIZE + B_IN_SIZE - 1) downto 0) := to_signed(integer(134217728),(A_IN_SIZE + B_IN_SIZE));
    begin
        -- Sigmoid function possesses an exponential element combined with a division
        -- 14 Pieces Piecewise Linear Approximation
        -- From the article: "FPGA Implementation for the Sigmoid with Piecewise LInear Fitting Method Based on Curvature Analysis"
        -- Calculate the output of the function based on the conditions
        -- Remember that the input vector has a 48 bit width with 1 sign bit, 25 fractional bits and 22 integer bits
        -- The multiplication coeficient is given in a Q1.8 format, therefore it contains 9 bits, 9 bits must be subtracted from the input
        x_aux := shift_right(x,9);
        -- The new resolution of the approximation contains 1 sign bit, 22 integer bits and 16 fractional bits for a total of 39 bit width
        if (x <= p1) then -- X"F0000000" Q7.25 format
            y := zero; -- X"000000000000"; 
        elsif ((x > p1) AND (x <= p2)) then
            -- Aggregation of new numbers must have 24 fractional bits at most 0.01875 = 1229
            y := resize((x_aux + 314573),(A_IN_SIZE + B_IN_SIZE));
            if (y < zero) then --to_signed(integer(0),(A_IN_SIZE + B_IN_SIZE))
                y := zero;
            end if;
        elsif ((x > p2) AND (x <= p3)) then 
            y := resize((6*x_aux + 1912099),(A_IN_SIZE + B_IN_SIZE));
        elsif ((x > p3) AND (x <= p4)) then           
            y := resize((18*x_aux + 4231046),(A_IN_SIZE + B_IN_SIZE));
        elsif ((x > p4) AND (x <= p5)) then
            y := resize((38*x_aux + 6870438),(A_IN_SIZE + B_IN_SIZE));
        elsif ((x > p5) AND (x <= p6)) then
            y := resize((61*x_aux + 8388608),(A_IN_SIZE + B_IN_SIZE));
        elsif ((x > p6) AND (x <= p7)) then
            y := resize((38*x_aux + 9906778),(A_IN_SIZE + B_IN_SIZE));
        elsif ((x > p7) AND (x <= p8)) then
            y := resize((18*x_aux + 12546170),(A_IN_SIZE + B_IN_SIZE));
        elsif ((x > p8) AND (x <= p9)) then
            y := resize((6*x_aux + 14865117),(A_IN_SIZE + B_IN_SIZE));
        elsif ((x > p9) AND (x <= p10)) then
            y := resize((x_aux + 16462643),(A_IN_SIZE + B_IN_SIZE));
            if (y > one) then
                y := one; -- X"000008000000";
            end if;
        else
            y := one; -- X"000008000000"; 
        end if;        
        -- The output contains 24 fractional bits, this is what matters, the representation is Q24.24
        -- It's highly probable that the output only contains fractional values, if it has a value greater than 1 or less than 0 it makes no sense!
    return y;
end;

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- Define the weights and the biases of the neuron
-- Creates a 16x12 array for the initial weights (Format Q11.14)
type in_W1 is array (0 to (W_SIZE - 1), 0 to (N_HIDDEN - 1)) of signed((W_BIT_WIDTH - 1) downto 0);
constant w1 : in_W1 := (
    (to_signed(integer(-14104),W_BIT_WIDTH),to_signed(integer(-7263),W_BIT_WIDTH),to_signed(integer(6615),W_BIT_WIDTH),to_signed(integer(-11190),W_BIT_WIDTH),
     to_signed(integer(2410361),W_BIT_WIDTH),to_signed(integer(-3971303),W_BIT_WIDTH),to_signed(integer(-13780),W_BIT_WIDTH),to_signed(integer(2213),W_BIT_WIDTH),
     to_signed(integer(2798),W_BIT_WIDTH),to_signed(integer(894),W_BIT_WIDTH),to_signed(integer(-3631),W_BIT_WIDTH),to_signed(integer(-15373),W_BIT_WIDTH)),
    (to_signed(integer(8558),W_BIT_WIDTH),to_signed(integer(-5473),W_BIT_WIDTH),to_signed(integer(-5545),W_BIT_WIDTH),to_signed(integer(9336),W_BIT_WIDTH),
     to_signed(integer(2493396),W_BIT_WIDTH),to_signed(integer(-2677339),W_BIT_WIDTH),to_signed(integer(-8370),W_BIT_WIDTH),to_signed(integer(-2641),W_BIT_WIDTH),
     to_signed(integer(9774),W_BIT_WIDTH),to_signed(integer(3382),W_BIT_WIDTH),to_signed(integer(-10737),W_BIT_WIDTH),to_signed(integer(-7716),W_BIT_WIDTH)),
    (to_signed(integer(-6655),W_BIT_WIDTH),to_signed(integer(-3088),W_BIT_WIDTH),to_signed(integer(-14319),W_BIT_WIDTH),to_signed(integer(24386),W_BIT_WIDTH),
     to_signed(integer(2575217),W_BIT_WIDTH),to_signed(integer(-1713197),W_BIT_WIDTH),to_signed(integer(15751),W_BIT_WIDTH),to_signed(integer(-5776),W_BIT_WIDTH),
     to_signed(integer(4674),W_BIT_WIDTH),to_signed(integer(-8605),W_BIT_WIDTH),to_signed(integer(-3203),W_BIT_WIDTH),to_signed(integer(-6781),W_BIT_WIDTH)),
    (to_signed(integer(-3840),W_BIT_WIDTH),to_signed(integer(-12522),W_BIT_WIDTH),to_signed(integer(-4321),W_BIT_WIDTH),to_signed(integer(19245),W_BIT_WIDTH),
     to_signed(integer(2587596),W_BIT_WIDTH),to_signed(integer(-1097673),W_BIT_WIDTH),to_signed(integer(2899),W_BIT_WIDTH),to_signed(integer(-2209),W_BIT_WIDTH),
     to_signed(integer(-11016),W_BIT_WIDTH),to_signed(integer(-15229),W_BIT_WIDTH),to_signed(integer(-6067),W_BIT_WIDTH),to_signed(integer(13533),W_BIT_WIDTH)),
    (to_signed(integer(-15533),W_BIT_WIDTH),to_signed(integer(-9329),W_BIT_WIDTH),to_signed(integer(-15709),W_BIT_WIDTH),to_signed(integer(6824),W_BIT_WIDTH),
     to_signed(integer(2529663),W_BIT_WIDTH),to_signed(integer(-906603),W_BIT_WIDTH),to_signed(integer(6282),W_BIT_WIDTH),to_signed(integer(-11177),W_BIT_WIDTH),
     to_signed(integer(-5147),W_BIT_WIDTH),to_signed(integer(14892),W_BIT_WIDTH),to_signed(integer(-11953),W_BIT_WIDTH),to_signed(integer(10578),W_BIT_WIDTH)),
    (to_signed(integer(6208),W_BIT_WIDTH),to_signed(integer(-16168),W_BIT_WIDTH),to_signed(integer(-12164),W_BIT_WIDTH),to_signed(integer(3041),W_BIT_WIDTH),
     to_signed(integer(2322229),W_BIT_WIDTH),to_signed(integer(-1244190),W_BIT_WIDTH),to_signed(integer(15265),W_BIT_WIDTH),to_signed(integer(918),W_BIT_WIDTH),
     to_signed(integer(-15967),W_BIT_WIDTH),to_signed(integer(13705),W_BIT_WIDTH),to_signed(integer(-20100),W_BIT_WIDTH),to_signed(integer(-9747),W_BIT_WIDTH)),
    (to_signed(integer(13812),W_BIT_WIDTH),to_signed(integer(-2957),W_BIT_WIDTH),to_signed(integer(5724),W_BIT_WIDTH),to_signed(integer(18474),W_BIT_WIDTH),
     to_signed(integer(1947294),W_BIT_WIDTH),to_signed(integer(-2179217),W_BIT_WIDTH),to_signed(integer(-9774),W_BIT_WIDTH),to_signed(integer(-7718),W_BIT_WIDTH),
     to_signed(integer(-10778),W_BIT_WIDTH),to_signed(integer(13456),W_BIT_WIDTH),to_signed(integer(-14592),W_BIT_WIDTH),to_signed(integer(-10914),W_BIT_WIDTH)),
    (to_signed(integer(-14062),W_BIT_WIDTH),to_signed(integer(12482),W_BIT_WIDTH),to_signed(integer(-6138),W_BIT_WIDTH),to_signed(integer(-23710),W_BIT_WIDTH),
     to_signed(integer(1326395),W_BIT_WIDTH),to_signed(integer(-3761503),W_BIT_WIDTH),to_signed(integer(11681),W_BIT_WIDTH),to_signed(integer(-13123),W_BIT_WIDTH),
     to_signed(integer(3402),W_BIT_WIDTH),to_signed(integer(-2125),W_BIT_WIDTH),to_signed(integer(-28588),W_BIT_WIDTH),to_signed(integer(-8818),W_BIT_WIDTH)),
    (to_signed(integer(-8982),W_BIT_WIDTH),to_signed(integer(785),W_BIT_WIDTH),to_signed(integer(13790),W_BIT_WIDTH),to_signed(integer(-24688),W_BIT_WIDTH),
     to_signed(integer(456155),W_BIT_WIDTH),to_signed(integer(-6009502),W_BIT_WIDTH),to_signed(integer(8707),W_BIT_WIDTH),to_signed(integer(-13376),W_BIT_WIDTH),
     to_signed(integer(7229),W_BIT_WIDTH),to_signed(integer(15166),W_BIT_WIDTH),to_signed(integer(-11151),W_BIT_WIDTH),to_signed(integer(-8818),W_BIT_WIDTH)),
    (to_signed(integer(-2624),W_BIT_WIDTH),to_signed(integer(-2987),W_BIT_WIDTH),to_signed(integer(11159),W_BIT_WIDTH),to_signed(integer(-76655),W_BIT_WIDTH),
     to_signed(integer(-712666),W_BIT_WIDTH),to_signed(integer(-8870309),W_BIT_WIDTH),to_signed(integer(2683),W_BIT_WIDTH),to_signed(integer(14095),W_BIT_WIDTH),
     to_signed(integer(-9272),W_BIT_WIDTH),to_signed(integer(2711),W_BIT_WIDTH),to_signed(integer(-8400),W_BIT_WIDTH),to_signed(integer(-15921),W_BIT_WIDTH)),
    (to_signed(integer(-1805),W_BIT_WIDTH),to_signed(integer(-13287),W_BIT_WIDTH),to_signed(integer(-12921),W_BIT_WIDTH),to_signed(integer(46239),W_BIT_WIDTH),
     to_signed(integer(2268850),W_BIT_WIDTH),to_signed(integer(873448),W_BIT_WIDTH),to_signed(integer(-16354),W_BIT_WIDTH),to_signed(integer(-11905),W_BIT_WIDTH),
     to_signed(integer(-9565),W_BIT_WIDTH),to_signed(integer(-1494),W_BIT_WIDTH),to_signed(integer(-26139),W_BIT_WIDTH),to_signed(integer(-2843),W_BIT_WIDTH)),
    (to_signed(integer(-7255),W_BIT_WIDTH),to_signed(integer(-5656),W_BIT_WIDTH),to_signed(integer(7098),W_BIT_WIDTH),to_signed(integer(29732),W_BIT_WIDTH),
     to_signed(integer(2471904),W_BIT_WIDTH),to_signed(integer(338271),W_BIT_WIDTH),to_signed(integer(9132),W_BIT_WIDTH),to_signed(integer(-2394),W_BIT_WIDTH),
     to_signed(integer(-16220),W_BIT_WIDTH),to_signed(integer(1595),W_BIT_WIDTH),to_signed(integer(3863),W_BIT_WIDTH),to_signed(integer(-13017),W_BIT_WIDTH)),
    (to_signed(integer(11794),W_BIT_WIDTH),to_signed(integer(-4088),W_BIT_WIDTH),to_signed(integer(-12604),W_BIT_WIDTH),to_signed(integer(41817),W_BIT_WIDTH),
     to_signed(integer(2673534),W_BIT_WIDTH),to_signed(integer(-674117),W_BIT_WIDTH),to_signed(integer(-646),W_BIT_WIDTH),to_signed(integer(3057),W_BIT_WIDTH),
     to_signed(integer(6385),W_BIT_WIDTH),to_signed(integer(9232),W_BIT_WIDTH),to_signed(integer(485),W_BIT_WIDTH),to_signed(integer(-4668),W_BIT_WIDTH)),
    (to_signed(integer(-14401),W_BIT_WIDTH),to_signed(integer(-4134),W_BIT_WIDTH),to_signed(integer(3051),W_BIT_WIDTH),to_signed(integer(17170),W_BIT_WIDTH),
     to_signed(integer(2768015),W_BIT_WIDTH),to_signed(integer(-2215183),W_BIT_WIDTH),to_signed(integer(8399),W_BIT_WIDTH),to_signed(integer(10659),W_BIT_WIDTH),
     to_signed(integer(10862),W_BIT_WIDTH),to_signed(integer(-1820),W_BIT_WIDTH),to_signed(integer(-24389),W_BIT_WIDTH),to_signed(integer(-12198),W_BIT_WIDTH)),
    (to_signed(integer(-11457),W_BIT_WIDTH),to_signed(integer(7063),W_BIT_WIDTH),to_signed(integer(3224),W_BIT_WIDTH),to_signed(integer(23821),W_BIT_WIDTH),
     to_signed(integer(2798228),W_BIT_WIDTH),to_signed(integer(-4242255),W_BIT_WIDTH),to_signed(integer(-4127),W_BIT_WIDTH),to_signed(integer(-9853),W_BIT_WIDTH),
     to_signed(integer(926),W_BIT_WIDTH),to_signed(integer(-4277),W_BIT_WIDTH),to_signed(integer(-12147),W_BIT_WIDTH),to_signed(integer(-11765),W_BIT_WIDTH)),
    (to_signed(integer(-11385),W_BIT_WIDTH),to_signed(integer(15877),W_BIT_WIDTH),to_signed(integer(-15379),W_BIT_WIDTH),to_signed(integer(-14916),W_BIT_WIDTH),
     to_signed(integer(2667077),W_BIT_WIDTH),to_signed(integer(-6831693),W_BIT_WIDTH),to_signed(integer(918),W_BIT_WIDTH),to_signed(integer(14757),W_BIT_WIDTH),
     to_signed(integer(9303),W_BIT_WIDTH),to_signed(integer(-4708),W_BIT_WIDTH),to_signed(integer(-21423),W_BIT_WIDTH),to_signed(integer(12456),W_BIT_WIDTH))
);

-- Creates a 12x1 array for the internal weights (Format Q11.14)
type in_W2 is array (0 to (N_HIDDEN - 1)) of signed((W_BIT_WIDTH - 1) downto 0);
constant w2 : in_W2 := (
    to_signed(integer(5722),W_BIT_WIDTH),
    to_signed(integer(-3872),W_BIT_WIDTH),
    to_signed(integer(-511),W_BIT_WIDTH),
    to_signed(integer(1359),W_BIT_WIDTH),
    to_signed(integer(67737),W_BIT_WIDTH),
    to_signed(integer(94575),W_BIT_WIDTH),
    to_signed(integer(-14772),W_BIT_WIDTH),
    to_signed(integer(4350),W_BIT_WIDTH),
    to_signed(integer(-16373),W_BIT_WIDTH),
    to_signed(integer(8982),W_BIT_WIDTH),
    to_signed(integer(-3211),W_BIT_WIDTH),
    to_signed(integer(-10600),W_BIT_WIDTH)
);

-- Creates a 12x1 array for the initial biases (Format Q12.27)
type in_b1 is array (0 to (N_HIDDEN - 1)) of signed((B1_SIZE_INT + B1_SIZE_FRAC - 1) downto 0);
constant b1 : in_b1 := (
    to_signed(integer(-99502470),(B1_SIZE_INT + B1_SIZE_FRAC)),
    to_signed(integer(-30702735),(B1_SIZE_INT + B1_SIZE_FRAC)),
    to_signed(integer(-118499023),(B1_SIZE_INT + B1_SIZE_FRAC)),
    to_signed(integer(-1195685),(B1_SIZE_INT + B1_SIZE_FRAC)),
    to_signed(integer(-1455316),(B1_SIZE_INT + B1_SIZE_FRAC)),
    to_signed(integer(10947335),(B1_SIZE_INT + B1_SIZE_FRAC)),
    to_signed(integer(-4679576),(B1_SIZE_INT + B1_SIZE_FRAC)),
    to_signed(integer(-118381796),(B1_SIZE_INT + B1_SIZE_FRAC)),
    to_signed(integer(-46464187),(B1_SIZE_INT + B1_SIZE_FRAC)),
    to_signed(integer(-10999041),(B1_SIZE_INT + B1_SIZE_FRAC)),
    to_signed(integer(-7746675),(B1_SIZE_INT + B1_SIZE_FRAC)),
    to_signed(integer(-20672676),(B1_SIZE_INT + B1_SIZE_FRAC))
);

-- Creates a 1x1 array for the internal bias (Format Q19.25)
constant b2 : signed((B2_SIZE_INT + B2_SIZE_FRAC - 1) downto 0) := to_signed(integer(-169265641),(B2_SIZE_INT + B2_SIZE_FRAC));   

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- Comparation constants for the Normalization
constant Neg_Th : signed(DATA_WIDTH downto 0) := to_signed(integer(-4096),(DATA_WIDTH + 1)); 
constant Pos_Th : signed(DATA_WIDTH downto 0) := to_signed(integer(4096),(DATA_WIDTH + 1));
-- Triggering Threshold
constant Trig_Th : signed((A_IN_SIZE + B_IN_SIZE - 1) downto 0) := to_signed(integer(16777216),(A_IN_SIZE + B_IN_SIZE)); -- 0.5 is 8388608, 0.9 is approximately 15099494 (In truth is 0.899999976158142)
-- 0.75 is 12582912, 0.95 is 15938355 (In truth is 0.949999988079071), 0.96 is 16106127 (In truth is 0.949999988079071), 0.97 is 16273900 (In truth is 0.949999988079071), 0.98 is 16441672 (In truth is 0.949999988079071)
-- 0.99 is 16609444 (In truth is 0.949999988079071), 1 is 16777216 

-- Auxiliary Signals To Interconnect The Module And Its Components
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- n (64) Pre Registers to Store in the FIFO
type pre_save_reg_window is array (0 to (PRE_W_SIZE - 1)) of std_logic_vector((DATA_WIDTH - 1) downto 0);
signal data_del             : pre_save_reg_window                           := (others => (others => '0'));

-- Inputs of the Neural Network
type reg_window is array (0 to (W_SIZE - 1)) of signed((DATA_WIDTH) downto 0);
signal reg_data             : reg_window                                    := (others => (others => '0'));
type data_mult_in is array (0 to (W_SIZE - 1), 0 to (N_HIDDEN - 1)) of signed((DATA_WIDTH + W_BIT_WIDTH) downto 0);
signal data_m               : data_mult_in                                  := (others => (others => to_signed(integer(0),(DATA_WIDTH + W_BIT_WIDTH + 1))));
type data_sum_in_first is array (0 to ((W_SIZE/2) - 1), 0 to (N_HIDDEN - 1)) of signed((DATA_WIDTH + W_BIT_WIDTH) downto 0);
signal add_data             : data_sum_in_first                             := (others => (others => to_signed(integer(0),(DATA_WIDTH + W_BIT_WIDTH + 1))));
type data_sum_in_last is array (0 to ((W_SIZE/4) - 1), 0 to (N_HIDDEN - 1)) of signed((DATA_WIDTH + W_BIT_WIDTH) downto 0);
signal add_data_reg         : data_sum_in_last                              := (others => (others => to_signed(integer(0),(DATA_WIDTH + W_BIT_WIDTH + 1))));
type data_sum_in_end is array (0 to ((W_SIZE/8) - 1), 0 to (N_HIDDEN - 1)) of signed((DATA_WIDTH + W_BIT_WIDTH) downto 0);
signal add_data_reg_reg     : data_sum_in_end                               := (others => (others => to_signed(integer(0),(DATA_WIDTH + W_BIT_WIDTH + 1))));
type hid_agg is array (0 to (N_HIDDEN - 1)) of signed((DATA_WIDTH + W_BIT_WIDTH) downto 0);
signal h_j_reg              : hid_agg                                       := (others => (others => '0'));

-- Hidden Neurons (1 hidden layer of 12)
type hidden_window is array (0 to (N_HIDDEN - 1)) of signed((A_IN_SIZE + B_IN_SIZE - 1) downto 0);
signal h_j, hidden_data     : hidden_window                                 := (others => (others => '0'));
type hidden_mult is array (0 to (N_HIDDEN - 1)) of signed((A_IN_SIZE + B_IN_SIZE + W_BIT_WIDTH - 1) downto 0); 
signal hid_m                : hidden_mult                                   := (others => (others => '0')); 
type hidden_add is array (0 to ((N_HIDDEN/2) - 1)) of signed((A_IN_SIZE + B_IN_SIZE + W_BIT_WIDTH - 1) downto 0);
signal add_hid              : hidden_add                                    := (others => (others => '0'));
type hidden_add_reg is array (0 to ((N_HIDDEN/4) - 1)) of signed((A_IN_SIZE + B_IN_SIZE + W_BIT_WIDTH - 1) downto 0);
signal add_hid_reg          : hidden_add_reg                                := (others => (others => '0'));
type hidden_add_reg_reg is array (0 to (N_HIDDEN/6 - 1)) of signed((A_IN_SIZE + B_IN_SIZE + W_BIT_WIDTH - 1) downto 0);
signal add_hid_reg_reg      : hidden_add_reg_reg                            := (others => (others => '0'));
signal y_j_reg              : signed((A_IN_SIZE + B_IN_SIZE + W_BIT_WIDTH - 1) downto 0) := (others => '0');

-- Output Layer
signal y_j, y_predict       : signed((A_IN_SIZE + B_IN_SIZE - 1) downto 0)  := (others => '0');

-- Auxiliary Output Of The Module
signal trigger              : std_logic                                     := '0';

-- Normalized Input Process Signals
signal data_sign            : signed(DATA_WIDTH downto 0)                   := (others => '0');
signal data_norm            : signed(DATA_WIDTH downto 0)                   := (others => '0');
signal Aux_Sum              : signed(DATA_WIDTH downto 0)                   := (others => '0');
signal Aux_Sub              : signed(DATA_WIDTH downto 0)                   := (others => '0');
    
begin

    -- Create the Delays For The Data Used By The Output Of The Module (Given To The FIFO A 64 Samples Pre Window Data)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    -- Create a For Generate To Create The Assignation Of Registers In Chain
    DATA_DELAY_GEN : for i in 0 to (PRE_W_SIZE - 1) generate
        -- Initial Register Assignation (Will Always Be The Input Data)
        FIRST_DEL_GEN : if (i = 0) generate
            FIRST_DEL_PROC : process(data, clk, rst)
            begin
                if rising_edge(clk) then
                    if (rst = '1') then
                        data_del(i) <= (others => '0');
                    else
                        data_del(i) <= data;
                    end if;
                end if;
            end process FIRST_DEL_PROC;            
        end generate FIRST_DEL_GEN;
    
        -- Consecutive Registers Assignation / Registers Chain
        CHAIN_DEL_GEN : if (i > 0) generate
            CHAIN_DEL_PROC : process(data_del, clk, rst)
            begin
                if rising_edge(clk) then
                    if (rst = '1') then
                        data_del(i) <= (others => '0');
                    else
                        data_del(i) <= data_del(i-1);
                    end if;
                end if;
            end process CHAIN_DEL_PROC;
        end generate CHAIN_DEL_GEN;
    end generate DATA_DELAY_GEN;
    
    -- Normalize the Filtered Data that is Entering the Module
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    -- Use a Simple Comparation Threshold
    NORM_DATA : process(filt_data, data_sign, Aux_Sum, Aux_Sub)
    begin
        -- After lots of hours of understanding, the normalized data could be represented as
        -- Q2.13 format and normalization is done by purely checking if the data is above 4096 or not
        -- Signed input data (Change the input data from std_logic_vector to signed and resize it)
        data_sign   <= resize(signed(filt_data),(DATA_WIDTH + 1));
        -- Auxiliar addition
        Aux_Sum     <= data_sign + 1;
        -- Auxiliar subtraction
        Aux_Sub     <= data_sign - 1;
        -- Create the Normalization conditional
        if (data_sign(data_sign'HIGH) = '0') then
            -- Positive number
            if (data_sign < Pos_Th) then
                data_norm <= data_sign;
            else
                data_norm <= Aux_Sum;
            end if;
        else
            -- Negative number
            if (data_sign <= Neg_Th) then
                data_norm <= Aux_Sub;
            else
                data_norm <= data_sign;
            end if;
        end if;
    end process NORM_DATA;
    
    -- Assign The Input Layer To The Network (Use Of 16 Registers)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    -- Create a For Generate To Create The Assignation Of Registers In Chain
    INPUT_DELAY_GEN : for i in 0 to (W_SIZE - 1) generate    
        -- Initial Register Assignation (Will Always Be The Normalized Data)
        FIRST_REG_GEN : if (i = 0) generate
            REG_ZERO_PROC : process(clk, rst, data_norm)
            begin 
                if rising_edge(clk) then
                    if (rst = '1') then
                        reg_data(i) <= (others => '0');
                    else
                        reg_data(i) <= data_norm;
                    end if;
                end if;
            end process REG_ZERO_PROC;
        end generate FIRST_REG_GEN;
        
        -- Consecutive Registers Assignation
        NEXT_REG_GEN: if (i > 0) generate
            GEN_CON_REG : process(clk, rst, reg_data)
            begin
                if rising_edge(clk) then
                    if (rst = '1') then
                        -- Clear The Registers
                        reg_data(i) <= (others => '0');
                    else
                        -- Assign the Input To This Register
                        reg_data(i) <= reg_data(i-1);
                    end if;
                end if;
            end process GEN_CON_REG;
        end generate NEXT_REG_GEN;
    end generate INPUT_DELAY_GEN;
    
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    -- Obtain the aggregation of each hidden neuron...          
    HIDDEN_AGG: for i in 0 to (N_HIDDEN - 1) generate
        -- Find the aggregation of each hidden neuron                                  
        -- Generate a Clocked Process to calculate the aggregation of each hidden neuron using pipeline stages
        INPUT_ADD_PROC_END : process(rst, clk, reg_data, data_m, add_data, add_data_reg, add_data_reg_reg, h_j_reg) 
        begin
            if rising_edge(clk) then
                if (rst = '1') then
                    -- Reset all the registers used in this pipelined process
                    data_m(0,i)             <= (others => '0');
                    data_m(1,i)             <= (others => '0');
                    data_m(2,i)             <= (others => '0');
                    data_m(3,i)             <= (others => '0');
                    data_m(4,i)             <= (others => '0');
                    data_m(5,i)             <= (others => '0');
                    data_m(6,i)             <= (others => '0');
                    data_m(7,i)             <= (others => '0');
                    data_m(8,i)             <= (others => '0');
                    data_m(9,i)             <= (others => '0');
                    data_m(10,i)            <= (others => '0');
                    data_m(11,i)            <= (others => '0');
                    data_m(12,i)            <= (others => '0');
                    data_m(13,i)            <= (others => '0');
                    data_m(14,i)            <= (others => '0');
                    data_m(15,i)            <= (others => '0');
                    add_data(0,i)           <= (others => '0');
                    add_data(1,i)           <= (others => '0');
                    add_data(2,i)           <= (others => '0');
                    add_data(3,i)           <= (others => '0');
                    add_data(4,i)           <= (others => '0');
                    add_data(5,i)           <= (others => '0');
                    add_data(6,i)           <= (others => '0');
                    add_data(7,i)           <= (others => '0');
                    add_data_reg(0,i)       <= (others => '0');
                    add_data_reg(1,i)       <= (others => '0');
                    add_data_reg(2,i)       <= (others => '0');
                    add_data_reg(3,i)       <= (others => '0');
                    add_data_reg_reg(0,i)   <= (others => '0');
                    add_data_reg_reg(1,i)   <= (others => '0');
                    h_j_reg(i)              <= (others => '0');
                    h_j(i)                  <= (others => '0');
                else
                    -- Obtain the multiplication values between each neuron and its weight
                    data_m(0,i)             <= reg_data(0)*w1(0,i);
                    data_m(1,i)             <= reg_data(1)*w1(1,i);
                    data_m(2,i)             <= reg_data(2)*w1(2,i);
                    data_m(3,i)             <= reg_data(3)*w1(3,i);
                    data_m(4,i)             <= reg_data(4)*w1(4,i);
                    data_m(5,i)             <= reg_data(5)*w1(5,i);
                    data_m(6,i)             <= reg_data(6)*w1(6,i);
                    data_m(7,i)             <= reg_data(7)*w1(7,i);
                    data_m(8,i)             <= reg_data(8)*w1(8,i);
                    data_m(9,i)             <= reg_data(9)*w1(9,i);
                    data_m(10,i)            <= reg_data(10)*w1(10,i);
                    data_m(11,i)            <= reg_data(11)*w1(11,i);
                    data_m(12,i)            <= reg_data(12)*w1(12,i);
                    data_m(13,i)            <= reg_data(13)*w1(13,i);
                    data_m(14,i)            <= reg_data(14)*w1(14,i);
                    data_m(15,i)            <= reg_data(15)*w1(15,i);
                    
                    -- Sum in pairs each result of the multiplication
                    add_data(0,i)           <= data_m(1,i) + data_m(0,i);
                    add_data(1,i)           <= data_m(3,i) + data_m(2,i);
                    add_data(2,i)           <= data_m(5,i) + data_m(4,i);
                    add_data(3,i)           <= data_m(7,i) + data_m(6,i);
                    add_data(4,i)           <= data_m(9,i) + data_m(8,i);
                    add_data(5,i)           <= data_m(11,i) + data_m(10,i); 
                    add_data(6,i)           <= data_m(13,i) + data_m(12,i);
                    add_data(7,i)           <= data_m(15,i) + data_m(14,i);  
                    
                    -- Sum in pairs the past stage
                    add_data_reg(0,i)       <= add_data(1,i) + add_data(0,i);
                    add_data_reg(1,i)       <= add_data(3,i) + add_data(2,i);
                    add_data_reg(2,i)       <= add_data(5,i) + add_data(4,i);
                    add_data_reg(3,i)       <= add_data(7,i) + add_data(6,i);
                    
                    -- Add the las two stages of the addition pipe (including the bias)
                    add_data_reg_reg(0,i)   <= add_data_reg(1,i) + add_data_reg(0,i);
                    add_data_reg_reg(1,i)   <= b1(i) + add_data_reg(3,i) + add_data_reg(2,i);
                    
                    -- Obtain the final aggregation
                    h_j_reg(i)              <= add_data_reg_reg(1,i) + add_data_reg_reg(0,i);
                    
                    -- Resize the output of the pipeline
                    h_j(i)                  <= resize(h_j_reg(i),(A_IN_SIZE + B_IN_SIZE)); 
                end if;
            end if;
        end process INPUT_ADD_PROC_END;            
                           
        -- Obtain the value of the activation function
        hidden_data(i)  <= ReLU(h_j(i));
    end generate HIDDEN_AGG;                   
                          
    -- Find the aggregation of the output layer
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    -- Generate a Clocked Process to calculate the aggregation of the output layer using pipeline stages
    ADD_PROC_END : process(rst, clk, hidden_data, hid_m, add_hid, add_hid_reg, add_hid_reg_reg, y_j_reg) 
    begin
        if rising_edge(clk) then
            if (rst = '1') then
                -- Reset all the registers used in this pipelined process
                hid_m               <= (others => (others => '0'));
                add_hid             <= (others => (others => '0'));
                add_hid_reg         <= (others => (others => '0'));
                add_hid_reg_reg     <= (others => (others => '0'));
                y_j_reg             <= (others => '0');
                y_j                 <= (others => '0');
            else
                -- Obtain the multiplication values between each neuron and its weight
                hid_m(0)            <= hidden_data(0)*w2(0);
                hid_m(1)            <= hidden_data(1)*w2(1);
                hid_m(2)            <= hidden_data(2)*w2(2);
                hid_m(3)            <= hidden_data(3)*w2(3);
                hid_m(4)            <= hidden_data(4)*w2(4);
                hid_m(5)            <= hidden_data(5)*w2(5);
                hid_m(6)            <= hidden_data(6)*w2(6);
                hid_m(7)            <= hidden_data(7)*w2(7);
                hid_m(8)            <= hidden_data(8)*w2(8);
                hid_m(9)            <= hidden_data(9)*w2(9);
                hid_m(10)           <= hidden_data(10)*w2(10);
                hid_m(11)           <= hidden_data(11)*w2(11);
                
                -- Sum in pairs each result of the multiplication
                add_hid(0)          <= hid_m(1) + hid_m(0);
                add_hid(1)          <= hid_m(3) + hid_m(2);
                add_hid(2)          <= hid_m(5) + hid_m(4);
                add_hid(3)          <= hid_m(7) + hid_m(6);
                add_hid(4)          <= hid_m(9) + hid_m(8);
                add_hid(5)          <= hid_m(11) + hid_m(10); 
                
                -- Sum in pairs the past stage
                add_hid_reg(0)      <= add_hid(1) + add_hid(0);
                add_hid_reg(1)      <= add_hid(3) + add_hid(2);
                add_hid_reg(2)      <= add_hid(5) + add_hid(4);
                
                -- Add the las two stages of the addition pipe (including the bias)
                add_hid_reg_reg(0)  <= add_hid_reg(1) + add_hid_reg(0);
                add_hid_reg_reg(1)  <= b2 + add_hid_reg(2);
                
                -- Obtain the final aggregation
                y_j_reg             <= add_hid_reg_reg(1) + add_hid_reg_reg(0);
                
                -- Resize the output of the pipeline
                y_j                 <= resize(y_j_reg,(A_IN_SIZE + B_IN_SIZE)); 
            end if;
        end if;
    end process ADD_PROC_END;  
                    
    -- Calculate the output value of the Network (Prediction)
    y_predict       <= Sigmoid(y_j);

    -- Check the Trigger Value
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    -- Assume the output should be related to the sigmoid value, if it is greater than 0.5 then triggers, else it does not do anything 
    TRIG_GEN: process(y_predict)
    begin
        if (y_predict >= Trig_Th) then
            -- 0000 0000 0000 0000 0000 0000. 1000 0000 0000 0000 0000 0000 bin = 8388608 dec = 80.00.00 hex
            -- This means that the first fractional element is 1 therefore the whole sum would be 
            -- 0.5 or above, therefore generate the trigger
            trigger <= '1';
        else
            -- Prediction is below half of the range of the sigmoid function, therefore the trigger should be kept low
            trigger <= '0';
        end if;
    end process TRIG_GEN; 

    -- Module Outputs Assignation
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    trigger_o       <= trigger AND data_valid;
    y_predict_o     <= y_predict;
    y_j_o           <= y_j;
    trigger_aux     <= trigger;
    norm_dt         <= data_norm;
    o_data          <= data_del(data_del'HIGH);                                 -- 64 Samples Delayed Data

end nNPM_arch;
